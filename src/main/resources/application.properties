spring.application.name=Reliable-Carriers

# Production Mode Configuration
# Set PRODUCTION_MODE=true in environment to enable production settings
# This affects logging, error handling, and security settings
production.mode=${PRODUCTION_MODE:false}

# Database Configuration
# Supports both MySQL and PostgreSQL - auto-detected from JDBC URL
# Use environment variables in production - defaults provided for development
# For PostgreSQL (Render): jdbc:postgresql://host:5432/database_name
# For MySQL (local): jdbc:mysql://localhost:3306/reliable_carriers?useSSL=false&serverTimezone=UTC
spring.datasource.url=${DB_URL:jdbc:mysql://localhost:3306/reliable_carriers?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true}
spring.datasource.username=${DB_USERNAME:root}
spring.datasource.password=${DB_PASSWORD:SupermanAndBatman_-_0501!}
# Driver auto-detected from URL (MySQL or PostgreSQL)
# Can be explicitly set via DB_DRIVER environment variable if needed
# PostgreSQL: org.postgresql.Driver
# MySQL: com.mysql.cj.jdbc.Driver
spring.datasource.driver-class-name=${DB_DRIVER:}

# JPA Configuration
# Database platform auto-detected from JDBC URL
# Can be explicitly set via DB_PLATFORM environment variable if needed
spring.jpa.database-platform=${DB_PLATFORM:}
# In production, set DB_DDL_AUTO=validate via environment variable
spring.jpa.hibernate.ddl-auto=${DB_DDL_AUTO:update}
# Disable SQL logging in production - controlled by PRODUCTION_MODE
spring.jpa.show-sql=${JPA_SHOW_SQL:false}
spring.jpa.properties.hibernate.format_sql=${JPA_FORMAT_SQL:false}
# Hibernate dialect auto-detected from database platform
# Can be explicitly set via HIBERNATE_DIALECT environment variable if needed
spring.jpa.properties.hibernate.dialect=${HIBERNATE_DIALECT:}

# MySQL Connection Pool Configuration
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1200000

# Application Configuration
app.name=${APP_NAME:Reliable Carriers}
app.base.url=${APP_BASE_URL:http://localhost:8080}
app.admin.email=${ADMIN_EMAIL:admin@reliablecarriers.co.za}
# Debug Mode (set to false in production)
# When enabled, shows additional debug information in logs
app.debug.mode=${APP_DEBUG_MODE:false}

# Session Configuration
# Session timeout: 20 minutes (1200 seconds) of inactivity
server.servlet.session.timeout=20m
spring.session.timeout=20m

# JWT Configuration
# IMPORTANT: In production, set JWT_SECRET via environment variable with a strong random key (min 256 bits)
jwt.secret=${JWT_SECRET:8ef248ba8564ab923ea77b106afd9bc5}
jwt.expiration=${JWT_EXPIRATION:86400000}

# Spring Configuration
spring.main.allow-circular-references=true

# Email Configuration - Supports Multiple Providers
# The application supports both Gmail SMTP and TurboSMTP via environment variables
# 
# PROVIDER SELECTION:
# - Railway (Production): Use Gmail SMTP (works, free)
# - Render (Staging): Use TurboSMTP (works on Render, free tier: 6000 emails/month)
#
# GMAIL SMTP Configuration (Railway - Production):
#   MAIL_HOST=smtp.gmail.com
#   MAIL_PORT=587 (or 465 for SSL)
#   MAIL_USE_SSL=false (true for port 465)
#   MAIL_USE_STARTTLS=true (false for port 465)
#   MAIL_PROTOCOL=smtp (smtps for port 465)
#   GMAIL_USERNAME=your-email@gmail.com
#   GMAIL_APP_PASSWORD=your-app-password
#
# TURBOSMTP Configuration (Render - Staging):
#   MAIL_HOST=smtp.turbosmtp.com
#   MAIL_PORT=587
#   MAIL_USE_SSL=false
#   MAIL_USE_STARTTLS=true
#   MAIL_PROTOCOL=smtp
#   TURBOSMTP_USERNAME=your-turbosmtp-username
#   TURBOSMTP_PASSWORD=your-turbosmtp-password
#
# The username and password will automatically use TurboSMTP if TURBOSMTP_USERNAME is set,
# otherwise it falls back to Gmail credentials
spring.mail.host=${MAIL_HOST:smtp.gmail.com}
spring.mail.port=${MAIL_PORT:587}
# Use TurboSMTP credentials if provided, otherwise use Gmail credentials
spring.mail.username=${TURBOSMTP_USERNAME:${GMAIL_USERNAME:ntshuxekochabalala80@gmail.com}}
spring.mail.password=${TURBOSMTP_PASSWORD:${GMAIL_APP_PASSWORD:qfdfnjgyrxjhtvlb}}
spring.mail.properties.mail.smtp.auth=true
# Use SSL for port 465, STARTTLS for port 587
spring.mail.properties.mail.smtp.ssl.enable=${MAIL_USE_SSL:false}
spring.mail.properties.mail.smtp.starttls.enable=${MAIL_USE_STARTTLS:true}
spring.mail.properties.mail.smtp.starttls.required=${MAIL_USE_STARTTLS:true}
# Increased timeouts for better reliability
spring.mail.properties.mail.smtp.connectiontimeout=30000
spring.mail.properties.mail.smtp.timeout=30000
spring.mail.properties.mail.smtp.writetimeout=30000
# Socket factory configuration - port should match MAIL_PORT
spring.mail.properties.mail.smtp.socketFactory.port=${MAIL_PORT:587}
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.smtp.socketFactory.fallback=false
# SSL trust configuration - supports both Gmail and TurboSMTP
spring.mail.properties.mail.smtp.ssl.trust=${MAIL_HOST:smtp.gmail.com}
spring.mail.properties.mail.smtp.ssl.protocols=TLSv1.2
# Transport protocol: smtp for port 587, smtps for port 465
spring.mail.properties.mail.transport.protocol=${MAIL_PROTOCOL:smtp}
# For port 465 (smtps), also configure smtps properties
spring.mail.properties.mail.smtps.auth=${MAIL_USE_SSL:false}
spring.mail.properties.mail.smtps.ssl.enable=${MAIL_USE_SSL:false}
spring.mail.properties.mail.smtps.ssl.trust=${MAIL_HOST:smtp.gmail.com}
# Enable debug for troubleshooting (set to false in production)
spring.mail.properties.mail.debug=${MAIL_DEBUG:false}
# Retry configuration
spring.mail.properties.mail.smtp.sendpartial=true
spring.mail.properties.mail.smtp.quitwait=false

# SMS Configuration (SMSPortal)
# In production, set SMS API credentials via environment variables
sms.api.url=https://rest.smsportal.com
sms.api.key=${SMSPORTAL_API_KEY:f4b7777e-d45b-4833-babf-da154601cc55}
sms.api.secret=${SMSPORTAL_API_SECRET:db281f2c-468e-4083-8932-e46f6bf82a82}
sms.provider=smsportal
app.notifications.sms.enabled=${SMS_ENABLED:true}

# SMSPortal specific configuration
sms.portal.api.url=https://rest.smsportal.com
sms.portal.auth.url=https://rest.smsportal.com/auth/token

# Google Maps API (for tracking)
# In production, set GOOGLE_MAPS_API_KEY via environment variable
google.maps.api.key=${GOOGLE_MAPS_API_KEY:AIzaSyDLgjJj0Ou8dO1CHzKzJWtbP59QlafVgBY}

# Paystack Configuration
# IMPORTANT: In production, use live keys (sk_live_... and pk_live_...) via environment variables
paystack.secret.key=${PAYSTACK_SECRET_KEY:sk_test_8602979f5d58106eef93d2af18b6b85802124ed0e}
paystack.public.key=${PAYSTACK_PUBLIC_KEY:pk_test_f0b259230b0894830add4ffac1d8075fa2e69286}
paystack.base.url=${PAYSTACK_BASE_URL:https://api.paystack.co}
paystack.mock.mode=${PAYSTACK_MOCK_MODE:false}
paystack.fallback.on.error=${PAYSTACK_FALLBACK_ON_ERROR:true}
paystack.timeout.seconds=${PAYSTACK_TIMEOUT:30}
paystack.retry.attempts=${PAYSTACK_RETRY_ATTEMPTS:3}
paystack.webhook.secret=${PAYSTACK_WEBHOOK_SECRET:your_webhook_secret_here}

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Profile Picture Upload Configuration
app.upload.dir=src/main/resources/static/uploads

# Logging Configuration
# In production, set PRODUCTION_MODE=true to use INFO level logging
# Default to INFO for production safety - set to DEBUG only in development
logging.level.com.reliablecarriers=${LOG_LEVEL_RELIABLE_CARRIERS:INFO}
logging.level.org.springframework.security=${LOG_LEVEL_SECURITY:WARN}
logging.level.org.springframework.web=${LOG_LEVEL_WEB:INFO}
logging.level.org.hibernate=${LOG_LEVEL_HIBERNATE:WARN}

# Notification Configuration
app.notifications.email.enabled=${EMAIL_NOTIFICATIONS_ENABLED:true}
app.notifications.sms.enabled=${SMS_NOTIFICATIONS_ENABLED:true}
app.tracking.url=${APP_TRACKING_URL:${APP_BASE_URL:http://localhost:8080}}

# SMS Provider Configuration
sms.provider=smsportal
sms.enabled=true

# Africa's Talking SMS Configuration (for ComprehensiveSmsService)
# Get these from https://account.africastalking.com/apps/sandbox/settings/key
sms.provider.api.key=${AFRICASTALKING_API_KEY:}
sms.provider.username=${AFRICASTALKING_USERNAME:}
sms.provider.base.url=${AFRICASTALKING_BASE_URL:https://api.africastalking.com/version1/messaging}
sms.sender.name=${SMS_SENDER_NAME:Reliable}

# 2FA Configuration
app.2fa.token.ttl.minutes=10
app.2fa.enabled=true

# Application Configuration - Use environment variables in production
# Remove hardcoded localhost URLs in production
app.base.url=${APP_BASE_URL:http://localhost:8080}

# OpenAI API Configuration (for AI Chatbot)
# AI is DISABLED by default - using free rule-based chatbot
# To enable AI later (when ready), set openai.api.enabled=true and add API key
openai.api.key=${OPENAI_API_KEY:}
openai.api.enabled=false
openai.api.model=${OPENAI_API_MODEL:gpt-3.5-turbo}

# Error Handling Configuration
# In production, set PRODUCTION_MODE=true to hide sensitive error details
server.error.include-message=${ERROR_INCLUDE_MESSAGE:never}
server.error.include-stacktrace=${ERROR_INCLUDE_STACKTRACE:never}
server.error.include-binding-errors=${ERROR_INCLUDE_BINDING_ERRORS:never}
server.error.include-exception=${ERROR_INCLUDE_EXCEPTION:false}
# Disable Spring Boot's default whitelabel error page to use custom error pages
server.error.whitelabel.enabled=false

# Spring Boot Actuator Configuration
# Restricted access in production - only expose essential endpoints
management.endpoints.web.exposure.include=${ACTUATOR_ENDPOINTS:health,info,metrics}
management.endpoint.health.show-details=${ACTUATOR_HEALTH_DETAILS:never}
management.endpoint.health.show-components=${ACTUATOR_HEALTH_COMPONENTS:never}
management.metrics.export.prometheus.enabled=${PROMETHEUS_ENABLED:false}
management.metrics.tags.application=${spring.application.name}

# OpenAPI/Swagger Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.packages-to-scan=com.reliablecarriers.Reliable.Carriers.controller

# Rate Limiting Configuration
# Can be overridden with environment variables: RATE_LIMIT_ENABLED, RATE_LIMIT_REQUESTS_PER_MINUTE
app.rate-limit.enabled=${RATE_LIMIT_ENABLED:true}
app.rate-limit.requests-per-minute=${RATE_LIMIT_REQUESTS_PER_MINUTE:100}
app.rate-limit.auth-requests-per-minute=10

# OCR Configuration (Document Text Extraction)
# Set ocr.enabled=true to enable OCR functionality
# Choose provider: tesseract, google-vision, or aws-textract
ocr.enabled=${OCR_ENABLED:false}
ocr.provider=${OCR_PROVIDER:tesseract}

# Google Cloud Vision API (for OCR)
google.cloud.vision.api.key=${GOOGLE_CLOUD_VISION_API_KEY:}

# Automated Verification Configuration (CIPC/SARS)
# Set verification.enabled=true to enable automated business verification
verification.enabled=${VERIFICATION_ENABLED:false}
verification.cipc.api.url=${VERIFICATION_CIPC_API_URL:}
verification.cipc.api.key=${VERIFICATION_CIPC_API_KEY:}
verification.sars.api.url=${VERIFICATION_SARS_API_URL:}
verification.sars.api.key=${VERIFICATION_SARS_API_KEY:}

# OAuth2 Client Configuration
# In production, set OAuth2 credentials via environment variables and update redirect URIs
# Google OAuth2 Configuration
spring.security.oauth2.client.registration.google.client-id=${GOOGLE_CLIENT_ID:94721916035-tcuij9c69pijsu49d70bl16tvg00qdnq.apps.googleusercontent.com}
spring.security.oauth2.client.registration.google.client-secret=${GOOGLE_CLIENT_SECRET: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}
spring.security.oauth2.client.registration.google.scope=openid,profile,email
# Update redirect URI in production to use APP_BASE_URL
spring.security.oauth2.client.registration.google.redirect-uri=${GOOGLE_REDIRECT_URI:${APP_BASE_URL:http://localhost:8080}/login/oauth2/code/google}

# Facebook OAuth2 Configuration
spring.security.oauth2.client.registration.facebook.client-id=${FACEBOOK_CLIENT_ID:4381358002114215}
spring.security.oauth2.client.registration.facebook.client-secret=${FACEBOOK_CLIENT_SECRET:a6e54e086f6db35e3eebcd748034a987}
spring.security.oauth2.client.registration.facebook.scope=email,public_profile
# Update redirect URI in production to use APP_BASE_URL
spring.security.oauth2.client.registration.facebook.redirect-uri=${FACEBOOK_REDIRECT_URI:${APP_BASE_URL:http://localhost:8080}/login/oauth2/code/facebook}

# OAuth2 Provider Configuration
spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/v2/auth
spring.security.oauth2.client.provider.google.token-uri=https://www.googleapis.com/oauth2/v4/token
spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v3/userinfo
spring.security.oauth2.client.provider.google.jwk-set-uri=https://www.googleapis.com/oauth2/v3/certs

spring.security.oauth2.client.provider.facebook.authorization-uri=https://www.facebook.com/v18.0/dialog/oauth
spring.security.oauth2.client.provider.facebook.token-uri=https://graph.facebook.com/v18.0/oauth/access_token
spring.security.oauth2.client.provider.facebook.user-info-uri=https://graph.facebook.com/v18.0/me?fields=id,name,email,first_name,last_name